package net.bladehunt.rpp.processor

import kotlinx.serialization.json.encodeToStream
import net.bladehunt.rpp.RppExtension
import net.bladehunt.rpp.api.Json
import net.bladehunt.rpp.build.BuildScope
import net.bladehunt.rpp.build.FileData
import net.bladehunt.rpp.build.ResourcePackProcessor
import net.bladehunt.rpp.model.FontDefinition
import net.bladehunt.rpp.model.FontProvider
import net.bladehunt.rpp.model.Resource
import net.bladehunt.rpp.util.java
import net.bladehunt.rpp.util.readJsonOrNull
import org.gradle.api.logging.Logging
import java.io.File
import java.io.Writer

private val LOGGER = Logging.getLogger(FontClassGeneratorProcessor::class.java)

data class FontClassGeneratorProcessor(
    val shouldProcess: Regex = Regex("^/?assets/.*/font/.*.jsonc?$")
) : FileProcessor<Nothing?> {
    override fun BuildScope.shouldExecute(file: FileData): Boolean =
        file.source.toRelativeString(rpp.layout.source).matches(shouldProcess)

    override fun BuildScope.process(file: FileData) {
        file.outputs.toList().forEach { output ->
            if (!output.extension.startsWith("json")) return@forEach
            val definition = output.readJsonOrNull<FontDefinition>() ?: return@forEach

            if (definition.codegen == null) return@forEach

            val outputDir = rpp.layout.build.generated.java
                .resolve(definition.codegen.packageQualifier.replace('.', '/'))

            outputDir.mkdirs()

            val outputClass = outputDir.resolve("${definition.codegen.className}.java")

            outputClass.createNewFile()

            file.outputs += outputClass

            output.outputStream().use { out -> Json.encodeToStream(definition.copy(codegen = null), out) }

            val split = output.path.split(File.separatorChar, '/')

            val assetsIndex = split.indexOf("assets")
            val fontIndex = split.indexOf("font")

            if (assetsIndex == -1 || fontIndex == -1 || split.size <= fontIndex + 1) return@forEach

            outputClass.writer().use {
                writeFile(
                    Resource(split[assetsIndex + 1], split[fontIndex + 1].split('.').first()),
                    definition,
                    it
                )
            }
        }
    }

    private fun writeFile(
        resource: Resource,
        definition: FontDefinition,
        out: Writer
    ) {
        val (packageQualifier, className) = requireNotNull(definition.codegen)

        out.write(
            java(
                """
                package $packageQualifier;
                
                import net.kyori.adventure.key.Key;
                import net.kyori.adventure.text.Component;
                
                // Generated by https://github.com/bladehuntmc/rpp
                public class $className {
                    public static final Key FONT_KEY = Key.key("${resource.namespace}", "${resource.value}");
            """.trimIndent()
            )
        )

        out.write("\n")

        var withoutName = 0

        definition.providers.forEach { provider ->
            when (provider) {
                is FontProvider.Bitmap -> {
                    val name = provider.name ?: run {
                        withoutName++
                        return@forEach
                    }

                    val firstChar = provider.chars.firstOrNull() ?: return@forEach

                    out.write(java("\n    public static final Component $name = Component.text(\"$firstChar\").font(FONT_KEY);"))
                }
                is FontProvider.Space -> {
                    provider.advances.forEach { (key, advance) ->
                        out.write(java("\n    public static final Component SPACE_${advance
                            .toString()
                            .replace('.', '_')
                            .replace("-","NEG_")
                            .removeSuffix("_0")
                        } = Component.text(\"$key\").font(FONT_KEY);"))
                    }
                }
                // TODO: Implement other providers
                else -> {}
            }
        }

        if (withoutName > 0) LOGGER.warn("$withoutName provider(s) in $resource does not have a name")

        out.write("\n")
        out.write("}")
    }

    override fun createContext(rpp: ResourcePackProcessor): Nothing? = null
}

fun RppExtension.generateFontClasses(
    shouldProcess: Regex = Regex("^/?assets/.*/font/.*.jsonc?$")
): FontClassGeneratorProcessor = FontClassGeneratorProcessor(shouldProcess).also {
    fileProcessors += it
}